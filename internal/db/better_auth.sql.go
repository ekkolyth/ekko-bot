// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: better_auth.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateAccount = `-- name: CreateAccount :one
INSERT INTO "account" ("id", "accountId", "providerId", "userId", "accessToken", "refreshToken", "idToken", "accessTokenExpiresAt", "refreshTokenExpiresAt", "scope", "password")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, "accountId", "providerId", "userId", "accessToken", "refreshToken", "idToken", "accessTokenExpiresAt", "refreshTokenExpiresAt", scope, password, "createdAt", "updatedAt"
`

type CreateAccountParams struct {
	ID                    string             `json:"id"`
	AccountId             string             `json:"accountId"`
	ProviderId            string             `json:"providerId"`
	UserId                string             `json:"userId"`
	AccessToken           *string            `json:"accessToken"`
	RefreshToken          *string            `json:"refreshToken"`
	IdToken               *string            `json:"idToken"`
	AccessTokenExpiresAt  pgtype.Timestamptz `json:"accessTokenExpiresAt"`
	RefreshTokenExpiresAt pgtype.Timestamptz `json:"refreshTokenExpiresAt"`
	Scope                 *string            `json:"scope"`
	Password              *string            `json:"password"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg *CreateAccountParams) (*Account, error) {
	row := q.db.QueryRow(ctx, CreateAccount,
		arg.ID,
		arg.AccountId,
		arg.ProviderId,
		arg.UserId,
		arg.AccessToken,
		arg.RefreshToken,
		arg.IdToken,
		arg.AccessTokenExpiresAt,
		arg.RefreshTokenExpiresAt,
		arg.Scope,
		arg.Password,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.AccountId,
		&i.ProviderId,
		&i.UserId,
		&i.AccessToken,
		&i.RefreshToken,
		&i.IdToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateSession = `-- name: CreateSession :one
INSERT INTO "session" ("id", "expiresAt", "token", "ipAddress", "userAgent", "userId")
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, "expiresAt", token, "createdAt", "updatedAt", "ipAddress", "userAgent", "userId"
`

type CreateSessionParams struct {
	ID        string             `json:"id"`
	ExpiresAt pgtype.Timestamptz `json:"expiresAt"`
	Token     string             `json:"token"`
	IpAddress *string            `json:"ipAddress"`
	UserAgent *string            `json:"userAgent"`
	UserId    string             `json:"userId"`
}

func (q *Queries) CreateSession(ctx context.Context, arg *CreateSessionParams) (*Session, error) {
	row := q.db.QueryRow(ctx, CreateSession,
		arg.ID,
		arg.ExpiresAt,
		arg.Token,
		arg.IpAddress,
		arg.UserAgent,
		arg.UserId,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ExpiresAt,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.UserId,
	)
	return &i, err
}

const CreateUser = `-- name: CreateUser :one
INSERT INTO "user" ("id", "name", "email", "emailVerified", "image")
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, email, "emailVerified", image, "createdAt", "updatedAt"
`

type CreateUserParams struct {
	ID            string  `json:"id"`
	Name          string  `json:"name"`
	Email         string  `json:"email"`
	EmailVerified bool    `json:"emailVerified"`
	Image         *string `json:"image"`
}

func (q *Queries) CreateUser(ctx context.Context, arg *CreateUserParams) (*User, error) {
	row := q.db.QueryRow(ctx, CreateUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.EmailVerified,
		arg.Image,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateVerification = `-- name: CreateVerification :one
INSERT INTO "verification" ("id", "identifier", "value", "expiresAt")
VALUES ($1, $2, $3, $4)
RETURNING id, identifier, value, "expiresAt", "createdAt", "updatedAt"
`

type CreateVerificationParams struct {
	ID         string             `json:"id"`
	Identifier string             `json:"identifier"`
	Value      string             `json:"value"`
	ExpiresAt  pgtype.Timestamptz `json:"expiresAt"`
}

func (q *Queries) CreateVerification(ctx context.Context, arg *CreateVerificationParams) (*Verification, error) {
	row := q.db.QueryRow(ctx, CreateVerification,
		arg.ID,
		arg.Identifier,
		arg.Value,
		arg.ExpiresAt,
	)
	var i Verification
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteAccount = `-- name: DeleteAccount :exec
DELETE FROM "account" WHERE "id" = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, DeleteAccount, id)
	return err
}

const DeleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM "session" WHERE "expiresAt" < CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, DeleteExpiredSessions)
	return err
}

const DeleteExpiredVerifications = `-- name: DeleteExpiredVerifications :exec
DELETE FROM "verification" WHERE "expiresAt" < CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredVerifications(ctx context.Context) error {
	_, err := q.db.Exec(ctx, DeleteExpiredVerifications)
	return err
}

const DeleteSession = `-- name: DeleteSession :exec
DELETE FROM "session" WHERE "id" = $1
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, DeleteSession, id)
	return err
}

const DeleteUser = `-- name: DeleteUser :exec
DELETE FROM "user" WHERE "id" = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, DeleteUser, id)
	return err
}

const DeleteVerification = `-- name: DeleteVerification :exec
DELETE FROM "verification" WHERE "id" = $1
`

func (q *Queries) DeleteVerification(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, DeleteVerification, id)
	return err
}

const GetAccountByID = `-- name: GetAccountByID :one
SELECT id, "accountId", "providerId", "userId", "accessToken", "refreshToken", "idToken", "accessTokenExpiresAt", "refreshTokenExpiresAt", scope, password, "createdAt", "updatedAt" FROM "account" WHERE "id" = $1
`

func (q *Queries) GetAccountByID(ctx context.Context, id string) (*Account, error) {
	row := q.db.QueryRow(ctx, GetAccountByID, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.AccountId,
		&i.ProviderId,
		&i.UserId,
		&i.AccessToken,
		&i.RefreshToken,
		&i.IdToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetAccountByProvider = `-- name: GetAccountByProvider :one
SELECT id, "accountId", "providerId", "userId", "accessToken", "refreshToken", "idToken", "accessTokenExpiresAt", "refreshTokenExpiresAt", scope, password, "createdAt", "updatedAt" FROM "account" WHERE "providerId" = $1 AND "accountId" = $2
`

type GetAccountByProviderParams struct {
	ProviderId string `json:"providerId"`
	AccountId  string `json:"accountId"`
}

func (q *Queries) GetAccountByProvider(ctx context.Context, arg *GetAccountByProviderParams) (*Account, error) {
	row := q.db.QueryRow(ctx, GetAccountByProvider, arg.ProviderId, arg.AccountId)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.AccountId,
		&i.ProviderId,
		&i.UserId,
		&i.AccessToken,
		&i.RefreshToken,
		&i.IdToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetAccountsByUserID = `-- name: GetAccountsByUserID :many
SELECT id, "accountId", "providerId", "userId", "accessToken", "refreshToken", "idToken", "accessTokenExpiresAt", "refreshTokenExpiresAt", scope, password, "createdAt", "updatedAt" FROM "account" WHERE "userId" = $1
`

func (q *Queries) GetAccountsByUserID(ctx context.Context, userid string) ([]*Account, error) {
	rows, err := q.db.Query(ctx, GetAccountsByUserID, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.AccountId,
			&i.ProviderId,
			&i.UserId,
			&i.AccessToken,
			&i.RefreshToken,
			&i.IdToken,
			&i.AccessTokenExpiresAt,
			&i.RefreshTokenExpiresAt,
			&i.Scope,
			&i.Password,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSessionByID = `-- name: GetSessionByID :one
SELECT id, "expiresAt", token, "createdAt", "updatedAt", "ipAddress", "userAgent", "userId" FROM "session" WHERE "id" = $1
`

func (q *Queries) GetSessionByID(ctx context.Context, id string) (*Session, error) {
	row := q.db.QueryRow(ctx, GetSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ExpiresAt,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.UserId,
	)
	return &i, err
}

const GetSessionByToken = `-- name: GetSessionByToken :one
SELECT id, "expiresAt", token, "createdAt", "updatedAt", "ipAddress", "userAgent", "userId" FROM "session" WHERE "token" = $1
`

func (q *Queries) GetSessionByToken(ctx context.Context, token string) (*Session, error) {
	row := q.db.QueryRow(ctx, GetSessionByToken, token)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ExpiresAt,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.UserId,
	)
	return &i, err
}

const GetSessionsByUserID = `-- name: GetSessionsByUserID :many
SELECT id, "expiresAt", token, "createdAt", "updatedAt", "ipAddress", "userAgent", "userId" FROM "session" WHERE "userId" = $1
`

func (q *Queries) GetSessionsByUserID(ctx context.Context, userid string) ([]*Session, error) {
	rows, err := q.db.Query(ctx, GetSessionsByUserID, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.ExpiresAt,
			&i.Token,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IpAddress,
			&i.UserAgent,
			&i.UserId,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, "emailVerified", image, "createdAt", "updatedAt" FROM "user" WHERE "email" = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	row := q.db.QueryRow(ctx, GetUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetUserByID = `-- name: GetUserByID :one

SELECT id, name, email, "emailVerified", image, "createdAt", "updatedAt" FROM "user" WHERE "id" = $1
`

// Better Auth queries
func (q *Queries) GetUserByID(ctx context.Context, id string) (*User, error) {
	row := q.db.QueryRow(ctx, GetUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetVerificationByID = `-- name: GetVerificationByID :one
SELECT id, identifier, value, "expiresAt", "createdAt", "updatedAt" FROM "verification" WHERE "id" = $1
`

func (q *Queries) GetVerificationByID(ctx context.Context, id string) (*Verification, error) {
	row := q.db.QueryRow(ctx, GetVerificationByID, id)
	var i Verification
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetVerificationByIdentifier = `-- name: GetVerificationByIdentifier :one
SELECT id, identifier, value, "expiresAt", "createdAt", "updatedAt" FROM "verification" WHERE "identifier" = $1
`

func (q *Queries) GetVerificationByIdentifier(ctx context.Context, identifier string) (*Verification, error) {
	row := q.db.QueryRow(ctx, GetVerificationByIdentifier, identifier)
	var i Verification
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateAccount = `-- name: UpdateAccount :one
UPDATE "account" 
SET "accessToken" = $2, "refreshToken" = $3, "idToken" = $4, "accessTokenExpiresAt" = $5, "refreshTokenExpiresAt" = $6, "scope" = $7, "password" = $8, "updatedAt" = CURRENT_TIMESTAMP
WHERE "id" = $1
RETURNING id, "accountId", "providerId", "userId", "accessToken", "refreshToken", "idToken", "accessTokenExpiresAt", "refreshTokenExpiresAt", scope, password, "createdAt", "updatedAt"
`

type UpdateAccountParams struct {
	ID                    string             `json:"id"`
	AccessToken           *string            `json:"accessToken"`
	RefreshToken          *string            `json:"refreshToken"`
	IdToken               *string            `json:"idToken"`
	AccessTokenExpiresAt  pgtype.Timestamptz `json:"accessTokenExpiresAt"`
	RefreshTokenExpiresAt pgtype.Timestamptz `json:"refreshTokenExpiresAt"`
	Scope                 *string            `json:"scope"`
	Password              *string            `json:"password"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg *UpdateAccountParams) (*Account, error) {
	row := q.db.QueryRow(ctx, UpdateAccount,
		arg.ID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.IdToken,
		arg.AccessTokenExpiresAt,
		arg.RefreshTokenExpiresAt,
		arg.Scope,
		arg.Password,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.AccountId,
		&i.ProviderId,
		&i.UserId,
		&i.AccessToken,
		&i.RefreshToken,
		&i.IdToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateSession = `-- name: UpdateSession :one
UPDATE "session" 
SET "expiresAt" = $2, "ipAddress" = $3, "userAgent" = $4, "updatedAt" = CURRENT_TIMESTAMP
WHERE "id" = $1
RETURNING id, "expiresAt", token, "createdAt", "updatedAt", "ipAddress", "userAgent", "userId"
`

type UpdateSessionParams struct {
	ID        string             `json:"id"`
	ExpiresAt pgtype.Timestamptz `json:"expiresAt"`
	IpAddress *string            `json:"ipAddress"`
	UserAgent *string            `json:"userAgent"`
}

func (q *Queries) UpdateSession(ctx context.Context, arg *UpdateSessionParams) (*Session, error) {
	row := q.db.QueryRow(ctx, UpdateSession,
		arg.ID,
		arg.ExpiresAt,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ExpiresAt,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.UserId,
	)
	return &i, err
}

const UpdateUser = `-- name: UpdateUser :one
UPDATE "user" 
SET "name" = $2, "email" = $3, "emailVerified" = $4, "image" = $5, "updatedAt" = CURRENT_TIMESTAMP
WHERE "id" = $1
RETURNING id, name, email, "emailVerified", image, "createdAt", "updatedAt"
`

type UpdateUserParams struct {
	ID            string  `json:"id"`
	Name          string  `json:"name"`
	Email         string  `json:"email"`
	EmailVerified bool    `json:"emailVerified"`
	Image         *string `json:"image"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg *UpdateUserParams) (*User, error) {
	row := q.db.QueryRow(ctx, UpdateUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.EmailVerified,
		arg.Image,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
